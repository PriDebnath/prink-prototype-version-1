<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Miro-lite — Big Upgrade</title>
<style>
  :root{--accent:#2563eb;--bg:#f4f6fb}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg)}
  .app{display:flex;height:100%}
  .sidebar{width:260px;background:#fff;border-right:1px solid #e6eefc;padding:12px;box-sizing:border-box;display:flex;flex-direction:column;gap:8px}
  .toolbar{display:flex;flex-wrap:wrap;gap:8px}
  .toolbar button{padding:8px;border-radius:8px;border:1px solid #e6eefc;background:white;cursor:pointer}
  .toolbar button.active{outline:2px solid var(--accent)}
  .boardWrap{flex:1;display:flex;flex-direction:column}
  .topbar{height:48px;display:flex;align-items:center;padding:8px;gap:8px;background:transparent}
  .viewport{flex:1;display:flex;align-items:stretch;justify-content:center;position:relative;overflow:hidden}
  #svgRoot{width:100%;height:100%;touch-action:none;background:linear-gradient(90deg,#fff 1px,transparent 1px) 0 0/20px 20px, linear-gradient(180deg,#fff 1px,transparent 1px) 0 0/20px 20px}
  .miniControls{position:absolute;right:12px;top:12px;display:flex;flex-direction:column;gap:6px}
  .info{font-size:13px;color:#555}
  .small{font-size:12px;padding:6px}
  input[type=color], input[type=number]{padding:6px;border-radius:6px;border:1px solid #ddd}
  .mobileHint{font-size:12px;color:#888;margin-top:6px}
</style>
</head>
<body>
<div class="app">
  <div class="sidebar">
    <h3 style="margin:4px 0">Miro-lite — Features</h3>
    <div class="toolbar" id="tools">
      <button data-tool="select" class="active">Select</button>
      <button data-tool="rect">Rectangle</button>
      <button data-tool="ellipse">Ellipse</button>
      <button data-tool="sticky">Sticky</button>
      <button data-tool="text">Text</button>
      <button data-tool="pen">Pen</button>
      <button data-tool="line">Connector</button>
      <button data-tool="frame">Frame</button>
    </div>

    <div style="display:flex;gap:8px;align-items:center">
      <label class="info">Fill</label>
      <input id="fill" type="color" value="#FFD966" />
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <label class="info">Stroke</label>
      <input id="stroke" type="color" value="#333333" />
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <label class="info">StrokeW</label>
      <input id="strokeW" type="number" value="2" style="width:70px" />
    </div>

    <div style="display:flex;gap:8px">
      <button id="groupBtn" class="small">Group</button>
      <button id="ungroupBtn" class="small">Ungroup</button>
    </div>
    <div style="display:flex;gap:8px">
      <button id="lockBtn" class="small">Lock</button>
      <button id="unlockBtn" class="small">Unlock</button>
    </div>

    <div style="display:flex;gap:8px">
      <button id="snapToggle" class="small">Snap: On</button>
      <button id="clearBtn" class="small">Clear Board</button>
    </div>

    <div style="display:flex;gap:8px">
      <button id="exportSvg" class="small">Export SVG</button>
      <button id="exportPng" class="small">Export PNG</button>
    </div>

    <div style="margin-top:6px">
      <div class="info">Saved automatically to localStorage</div>
      <div class="mobileHint">Tip: pinch to zoom, two-finger pan on mobile. Tap shapes to select. Drag connectors between shape centers.</div>
    </div>
  </div>

  <div class="boardWrap">
    <div class="topbar">
      <div class="info">Tool: <span id="currentTool">Select</span></div>
      <div style="width:14px"></div>
      <div class="info">Zoom: <span id="zoomLvl">100%</span></div>
    </div>

    <div class="viewport">
      <!-- SVG board -->
      <svg id="svgRoot" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMinYMin meet">
        <defs>
          <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="1" stdDeviation="2" flood-color="#000" flood-opacity="0.15"/>
          </filter>
        </defs>
        <g id="world"></g>
      </svg>

      <div class="miniControls">
        <button id="zoomIn" class="small">+</button>
        <button id="zoomOut" class="small">-</button>
      </div>
    </div>
  </div>
</div>

<script>
/* ========= App State ========= */
const svg = document.getElementById('svgRoot');
const world = document.getElementById('world');
const tools = document.getElementById('tools');
const currentToolLabel = document.getElementById('currentTool');
const zoomLvl = document.getElementById('zoomLvl');
let state = {
  tool: 'select',
  fill: document.getElementById('fill').value,
  stroke: document.getElementById('stroke').value,
  strokeW: parseInt(document.getElementById('strokeW').value)||2,
  snap: true,
  scale: 1,
  translate: {x:0,y:0},
  elements: [], // kept for saving / manipulation: {id,type,attrs,locked,group}
  selected: null,
  connecting: null, // connector start
  pointers: new Map()
};

/* Unique id */
const uid = (p=>'id_'+Math.random().toString(36).slice(2,9));

/* Grid snapping */
const gridSize = 20;
function snap(v){ return state.snap ? Math.round(v/gridSize)*gridSize : v; }

/* ========== Tools UI ========== */
tools.addEventListener('click', (e)=>{
  const b = e.target.closest('button');
  if(!b) return;
  const t = b.dataset.tool;
  if(t){
    state.tool = t;
    Array.from(tools.querySelectorAll('button')).forEach(bt=>bt.classList.toggle('active', bt===b));
    currentToolLabel.textContent = t[0].toUpperCase()+t.slice(1);
  }
});
document.getElementById('fill').addEventListener('change', (e)=>state.fill=e.target.value);
document.getElementById('stroke').addEventListener('change', (e)=>state.stroke=e.target.value);
document.getElementById('strokeW').addEventListener('change', (e)=>state.strokeW=parseInt(e.target.value)||2);

/* Buttons */
document.getElementById('snapToggle').addEventListener('click', (e)=>{
  state.snap = !state.snap;
  e.target.textContent = 'Snap: ' + (state.snap ? 'On' : 'Off');
});
document.getElementById('clearBtn').addEventListener('click', ()=>{
  if(confirm('Clear board?')) { world.innerHTML=''; state.elements=[]; state.selected=null; save(); }
});
document.getElementById('exportSvg').addEventListener('click', exportSVG);
document.getElementById('exportPng').addEventListener('click', exportPNG);
document.getElementById('zoomIn').addEventListener('click', ()=>zoom(1.2));
document.getElementById('zoomOut').addEventListener('click', ()=>zoom(1/1.2));

document.getElementById('groupBtn').addEventListener('click', groupSelected);
document.getElementById('ungroupBtn').addEventListener('click', ungroupSelected);
document.getElementById('lockBtn').addEventListener('click', ()=>setLock(true));
document.getElementById('unlockBtn').addEventListener('click', ()=>setLock(false));

/* ========= Coordinate utilities ========= */
function screenToWorld(pt){
  // SVG point to world coords considering scale & translate
  return { x: (pt.x - state.translate.x)/state.scale, y: (pt.y - state.translate.y)/state.scale };
}
function worldToScreen(pt){
  return { x: pt.x*state.scale + state.translate.x, y: pt.y*state.scale + state.translate.y };
}

/* ========= View transform (pan/zoom) ========= */
function applyTransform(){
  world.setAttribute('transform', `translate(${state.translate.x},${state.translate.y}) scale(${state.scale})`);
  zoomLvl.textContent = Math.round(state.scale*100)+'%';
}
function zoom(factor, cx, cy){
  cx = cx|| (svg.clientWidth/2);
  cy = cy|| (svg.clientHeight/2);
  // zoom around screen point (cx,cy)
  const before = screenToWorld({x:cx,y:cy});
  state.scale *= factor;
  // limit scales
  state.scale = Math.min(4, Math.max(0.2, state.scale));
  const after = screenToWorld({x:cx,y:cy});
  state.translate.x += (after.x - before.x) * state.scale;
  state.translate.y += (after.y - before.y) * state.scale;
  applyTransform();
}

/* ========= Element creation helpers ========= */
function createElement(type, x, y, w=140, h=80, extra={}){
  const id = uid();
  let node;
  if(type==='rect' || type==='sticky' || type==='frame'){
    node = document.createElementNS('http://www.w3.org/2000/svg','rect');
    node.setAttribute('rx', type==='sticky'?8:4);
    node.setAttribute('fill', state.fill);
    node.setAttribute('stroke', state.stroke);
    node.setAttribute('stroke-width', state.strokeW);
    node.setAttribute('width', w);
    node.setAttribute('height', h);
    node.setAttribute('x', x);
    node.setAttribute('y', y);
    if(type==='sticky') node.setAttribute('fill', state.fill);
    if(type==='frame'){ node.setAttribute('fill','none'); node.setAttribute('stroke','#999'); node.setAttribute('stroke-dasharray','6 4'); node.setAttribute('stroke-width','1.5'); }
  } else if(type==='ellipse'){
    node = document.createElementNS('http://www.w3.org/2000/svg','ellipse');
    node.setAttribute('cx', x + w/2);
    node.setAttribute('cy', y + h/2);
    node.setAttribute('rx', w/2);
    node.setAttribute('ry', h/2);
    node.setAttribute('fill', state.fill);
    node.setAttribute('stroke', state.stroke);
    node.setAttribute('stroke-width', state.strokeW);
  } else if(type==='text'){
    node = document.createElementNS('http://www.w3.org/2000/svg','text');
    node.setAttribute('x', x + 8);
    node.setAttribute('y', y + 20);
    node.setAttribute('fill', '#222');
    node.setAttribute('font-size', '16');
    node.textContent = extra.text||'Text';
  } else if(type==='line'){
    node = document.createElementNS('http://www.w3.org/2000/svg','line');
    node.setAttribute('x1', x);
    node.setAttribute('y1', y);
    node.setAttribute('x2', x + w);
    node.setAttribute('y2', y + h);
    node.setAttribute('stroke', state.stroke);
    node.setAttribute('stroke-width', state.strokeW);
    node.setAttribute('marker-end','url(#arrow)');
  } else if(type==='path'){ // freehand
    node = document.createElementNS('http://www.w3.org/2000/svg','path');
    node.setAttribute('d', extra.d||'');
    node.setAttribute('fill','none');
    node.setAttribute('stroke', state.stroke);
    node.setAttribute('stroke-width', state.strokeW);
    node.setAttribute('stroke-linecap','round');
    node.setAttribute('stroke-linejoin','round');
  } else return null;

  node.dataset._id = id;
  node.dataset._type = type;
  node.dataset.locked = 'false';
  node.style.cursor = 'move';
  attachElementEvents(node);
  world.appendChild(node);
  const meta = { id, type, node, locked:false, group:null };
  state.elements.push(meta);
  save();
  return meta;
}

/* ========= Element pointer interactions ========= */
let pointerDownInfo = null;

function attachElementEvents(node){
  node.addEventListener('pointerdown', (ev)=>{
    ev.stopPropagation();
    if(node.dataset.locked==='true') return;
    const pt = {x:ev.clientX, y:ev.clientY};
    pointerDownInfo = { node, startScreen:pt, startTransform:{x:state.translate.x, y:state.translate.y, s:state.scale}, elementStart: getElementPos(node) };
    // selection based on current tool
    if(state.tool === 'select'){
      selectNode(node);
      node.setPointerCapture(ev.pointerId);
    } else if(state.tool === 'line'){ // start connector
      state.connecting = { from: node, startWorld: screenToWorld(pt) };
      ev.preventDefault();
    } else if(state.tool === 'text' && node.dataset._type!=='text'){
      // create a text anchored at this shape
      const bbox = node.getBBox();
      const tmeta = createElement('text', bbox.x, bbox.y + bbox.height + 6, 120, 30, { text:'Label' });
      selectNode(tmeta.node);
    }
  });
}

function getElementPos(node){
  // Returns x,y,w,h in world coords for common shapes
  const t = node.dataset._type;
  if(t==='rect' || t==='sticky' || t==='frame'){
    return { x: parseFloat(node.getAttribute('x')), y: parseFloat(node.getAttribute('y')), w: parseFloat(node.getAttribute('width')), h: parseFloat(node.getAttribute('height')) };
  } else if(t==='ellipse'){
    const rx = parseFloat(node.getAttribute('rx')), ry = parseFloat(node.getAttribute('ry'));
    const cx = parseFloat(node.getAttribute('cx')), cy = parseFloat(node.getAttribute('cy'));
    return { x: cx - rx, y: cy - ry, w: rx*2, h: ry*2 };
  } else if(t==='text'){
    return { x: parseFloat(node.getAttribute('x')), y: parseFloat(node.getAttribute('y')), w: 100, h:20 };
  } else if(t==='line'){
    return { x: parseFloat(node.getAttribute('x1')), y: parseFloat(node.getAttribute('y1')), x2:parseFloat(node.getAttribute('x2')), y2:parseFloat(node.getAttribute('y2')) };
  } else if(t==='path'){
    return { }; // freehand handled separately
  }
}

/* ========= Selection ========= */
function selectNode(node){
  // clear prev selection
  state.selected = node;
  Array.from(world.querySelectorAll('[data-selected]')).forEach(n=>n.removeAttribute('data-selected'));
  node.setAttribute('data-selected','true');
  // show visual (outline)
  drawSelectionBox(node);
}

function drawSelectionBox(node){
  // Remove existing sel box
  const prev = world.querySelector('#__sel');
  if(prev) prev.remove();

  const bbox = node.getBBox();
  const g = document.createElementNS('http://www.w3.org/2000/svg','g');
  g.setAttribute('id','__sel');
  const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
  r.setAttribute('x', bbox.x - 6); r.setAttribute('y', bbox.y - 6);
  r.setAttribute('width', bbox.width + 12); r.setAttribute('height', bbox.height + 12);
  r.setAttribute('stroke','#2563eb'); r.setAttribute('fill','none'); r.setAttribute('stroke-dasharray','6 4');
  r.setAttribute('pointer-events','none');
  g.appendChild(r);
  // handle bottom-right
  const h = document.createElementNS('http://www.w3.org/2000/svg','rect');
  h.setAttribute('x', bbox.x + bbox.width - 6); h.setAttribute('y', bbox.y + bbox.height - 6);
  h.setAttribute('width',12); h.setAttribute('height',12); h.setAttribute('fill','#fff'); h.setAttribute('stroke','#2563eb');
  h.setAttribute('cursor','se-resize');
  g.appendChild(h);
  world.appendChild(g);
}

/* ========= Pointer interactions on the svg root (pan/zoom & creation) ========= */
svg.addEventListener('pointerdown', (ev)=>{
  svg.setPointerCapture(ev.pointerId);
  state.pointers.set(ev.pointerId, {x:ev.clientX, y:ev.clientY});
  if(state.tool==='rect' || state.tool==='ellipse' || state.tool==='sticky' || state.tool==='frame'){
    const start = screenToWorld({x:ev.clientX, y:ev.clientY});
    state._createTemp = {type: state.tool, x:start.x, y:start.y, node:null};
    // create temporary element with zero size (updated on move)
    const meta = createElement(state.tool, start.x, start.y, 4, 4);
    meta.node.setAttribute('opacity','0.9');
    state._createTemp.node = meta.node;
  } else if(state.tool==='pen'){
    const start = screenToWorld({x:ev.clientX, y:ev.clientY});
    const meta = createElement('path', start.x, start.y,0,0, { d: `M ${start.x} ${start.y}` });
    state._pen = {node: meta.node};
  } else {
    // start pan if not selecting an element
    state._maybePan = {startScreen:{x:ev.clientX,y:ev.clientY}, startTrans:{...state.translate}};
  }
});

svg.addEventListener('pointermove', (ev)=>{
  // update pointer map (for pinch)
  if(state.pointers.has(ev.pointerId)){
    state.pointers.set(ev.pointerId, {x:ev.clientX, y:ev.clientY});
  }

  if(state._createTemp && state._createTemp.node){
    const start = {x: state._createTemp.x, y: state._createTemp.y};
    const now = screenToWorld({x:ev.clientX, y:ev.clientY});
    let x = Math.min(start.x, now.x), y = Math.min(start.y, now.y);
    let w = Math.abs(now.x - start.x), h = Math.abs(now.y - start.y);
    if(state.snap){ x = snap(x); y = snap(y); w = Math.max(6, snap(w)); h = Math.max(6, snap(h)); }
    const n = state._createTemp.node;
    if(state._createTemp.type==='rect' || state._createTemp.type==='sticky' || state._createTemp.type==='frame'){
      n.setAttribute('x', x); n.setAttribute('y', y); n.setAttribute('width', w); n.setAttribute('height', h);
    } else if(state._createTemp.type==='ellipse'){
      n.setAttribute('cx', x + w/2); n.setAttribute('cy', y + h/2); n.setAttribute('rx', w/2); n.setAttribute('ry', h/2);
    }
  } else if(state._pen && state._pen.node){
    const pt = screenToWorld({x:ev.clientX, y:ev.clientY});
    // append to path d
    const d = state._pen.node.getAttribute('d') + ` L ${pt.x} ${pt.y}`;
    state._pen.node.setAttribute('d', d);
  } else if(pointerDownInfo && pointerDownInfo.node){
    // dragging an element (move)
    const dx = (ev.clientX - pointerDownInfo.startScreen.x)/state.scale;
    const dy = (ev.clientY - pointerDownInfo.startScreen.y)/state.scale;
    const node = pointerDownInfo.node;
    const t = node.dataset._type;
    if(t==='rect' || t==='sticky' || t==='frame'){
      let nx = pointerDownInfo.elementStart.x + dx;
      let ny = pointerDownInfo.elementStart.y + dy;
      if(state.snap){ nx = snap(nx); ny = snap(ny); }
      node.setAttribute('x', nx); node.setAttribute('y', ny);
    } else if(t==='ellipse'){
      let nx = pointerDownInfo.elementStart.x + dx;
      let ny = pointerDownInfo.elementStart.y + dy;
      if(state.snap){ nx = snap(nx); ny = snap(ny); }
      node.setAttribute('cx', nx + pointerDownInfo.elementStart.w/2);
      node.setAttribute('cy', ny + pointerDownInfo.elementStart.h/2);
    } else if(t==='text'){
      let nx = pointerDownInfo.elementStart.x + dx;
      let ny = pointerDownInfo.elementStart.y + dy;
      if(state.snap){ nx = snap(nx); ny = snap(ny); }
      node.setAttribute('x', nx); node.setAttribute('y', ny);
    } else if(t==='line'){
      node.setAttribute('x1', pointerDownInfo.elementStart.x + dx);
      node.setAttribute('y1', pointerDownInfo.elementStart.y + dy);
      node.setAttribute('x2', pointerDownInfo.elementStart.x2 + dx);
      node.setAttribute('y2', pointerDownInfo.elementStart.y2 + dy);
    }
    drawSelectionBox(node);
  } else if(state._maybePan){
    // panning world with single pointer drag (only when not creating)
    if(state.pointers.size === 1 && state.tool !== 'pen'){ // pan only if not drawing
      const now = {x:ev.clientX,y:ev.clientY};
      const sx = now.x - state._maybePan.startScreen.x;
      const sy = now.y - state._maybePan.startScreen.y;
      state.translate.x = state._maybePan.startTrans.x + sx;
      state.translate.y = state._maybePan.startTrans.y + sy;
      applyTransform();
    }
  }

  // pinch-to-zoom when two pointers active
  if(state.pointers.size===2){
    const pts = Array.from(state.pointers.values());
    const a = pts[0], b = pts[1];
    const curDist = Math.hypot(a.x-b.x, a.y-b.y);
    if(state._pinch && state._pinch.startDist){
      const factor = curDist / state._pinch.startDist;
      const center = {x:(a.x+b.x)/2, y:(a.y+b.y)/2};
      state.scale = state._pinch.startScale * factor;
      state.scale = Math.min(4, Math.max(0.2, state.scale));
      // adjust translate to keep center stable
      const before = screenToWorld(center);
      const after = { x:(center.x - state.translate.x)/state.scale, y:(center.y - state.translate.y)/state.scale };
      state.translate.x += (after.x - before.x) * state.scale;
      state.translate.y += (after.y - before.y) * state.scale;
      applyTransform();
    } else {
      state._pinch = { startDist: curDist, startScale: state.scale };
    }
  }
});

svg.addEventListener('pointerup', (ev)=>{
  svg.releasePointerCapture(ev.pointerId);
  state.pointers.delete(ev.pointerId);

  if(state._createTemp && state._createTemp.node){
    // finalize shape
    const n = state._createTemp.node;
    n.removeAttribute('opacity');
    state._createTemp = null;
    save();
  }
  if(state._pen && state._pen.node){
    const p = state._pen.node;
    if(!p.getAttribute('d') || p.getAttribute('d').length<5){ p.remove(); } // ignore tiny paths
    state._pen = null;
    save();
  }
  pointerDownInfo = null;
  state._maybePan = null;
  state._pinch = null;
});

/* ========= Click on background to deselect or create text ========= */
svg.addEventListener('click', (ev)=>{
  if(ev.target===svg || ev.target===world){
    // background click
    if(state.tool==='text'){
      const pt = screenToWorld({x:ev.clientX, y:ev.clientY});
      const meta = createElement('text', snap(pt.x), snap(pt.y), 140, 30, {text:'Text'});
      selectNode(meta.node);
    } else {
      // deselect
      state.selected = null;
      const prev = world.querySelector('#__sel'); if(prev) prev.remove();
    }
  } else if(state.tool==='line' && state.connecting){
    // complete connector - if clicked on element, connect to its center
    const target = ev.target;
    if(target && target.dataset && target.dataset._id){
      const fromNode = state.connecting.from;
      const toNode = target;
      const fromBox = fromNode.getBBox(), toBox = toNode.getBBox();
      const x1 = fromBox.x + fromBox.width/2, y1 = fromBox.y + fromBox.height/2;
      const x2 = toBox.x + toBox.width/2, y2 = toBox.y + toBox.height/2;
      const meta = createElement('line', x1, y1, x2 - x1, y2 - y1);
      meta.node.setAttribute('x1', x1); meta.node.setAttribute('y1', y1); meta.node.setAttribute('x2', x2); meta.node.setAttribute('y2', y2);
      state.connecting = null;
      save();
    }
  }
});

/* ========= Drag-to-resize handle support (selection handle) ========= */
/* For brevity this uses a simple pattern: when selected and pointerdown near handle, resize on pointermove */
svg.addEventListener('pointerdown', (ev)=>{
  const sel = world.querySelector('#__sel');
  if(!sel) return;
  // handle rect is second child
  const handle = sel.children[1];
  const hbb = handle.getBBox();
  // transform handle bbox to screen coords
  const pt = screenToWorld({x:ev.clientX,y:ev.clientY});
  // quick check using screen coords is complex; instead check if pointer is very near element's bottom-right in screen coords
  if(state.selected){
    const bbox = state.selected.getBBox();
    const br = worldToScreen({x: bbox.x + bbox.width, y: bbox.y + bbox.height});
    const dist = Math.hypot(ev.clientX - br.x, ev.clientY - br.y);
    if(dist < 24){
      // start resizing
      state._resizing = { node: state.selected, start: {x:ev.clientX, y:ev.clientY}, box: bbox };
      svg.setPointerCapture(ev.pointerId);
    }
  }
});
svg.addEventListener('pointermove', (ev)=>{
  if(state._resizing){
    const dx = (ev.clientX - state._resizing.start.x)/state.scale;
    const dy = (ev.clientY - state._resizing.start.y)/state.scale;
    const node = state._resizing.node;
    const t = node.dataset._type;
    if(t==='rect' || t==='sticky' || t==='frame'){
      const w = Math.max(10, state._resizing.box.width + dx);
      const h = Math.max(10, state._resizing.box.height + dy);
      node.setAttribute('width', state.snap? snap(w) : w);
      node.setAttribute('height', state.snap? snap(h) : h);
    } else if(t==='ellipse'){
      const w = Math.max(10, state._resizing.box.width + dx);
      const h = Math.max(10, state._resizing.box.height + dy);
      node.setAttribute('rx', (state.snap? snap(w) : w)/2);
      node.setAttribute('ry', (state.snap? snap(h) : h)/2);
    }
    drawSelectionBox(node);
  }
});
svg.addEventListener('pointerup', (ev)=>{
  if(state._resizing){ state._resizing = null; save(); }
});

/* ========= Utilities: group/ungroup/lock ========= */
function groupSelected(){
  if(!state.selected) return alert('Select an element to group with others (multi-select not implemented in this lightweight version).');
  alert('Simple group requires multi-select; this demo groups selected element into a <g> (placeholder).');
  // placeholder: actual multi-select would be needed — skipping full multi-select due to complexity in single-file demo
}
function ungroupSelected(){ alert('Ungroup (multi-select) — not implemented fully in this lightweight demo.'); }
function setLock(flag){
  if(!state.selected) return;
  state.selected.dataset.locked = flag ? 'true' : 'false';
  state.selected.style.opacity = flag ? 0.6 : 1;
  save();
}

/* ========= Exporting ========= */
function exportSVG(){
  // serialize world inside an SVG with transforms applied
  const clone = svg.cloneNode(true);
  // apply transform so children are in world coords
  const worldG = clone.querySelector('#world');
  worldG.removeAttribute('transform'); // we'll bake transform into shapes by wrapping
  const view = document.createElementNS('http://www.w3.org/2000/svg','g');
  view.appendChild(worldG.cloneNode(true));
  const outSvg = document.createElementNS('http://www.w3.org/2000/svg','svg');
  outSvg.setAttribute('xmlns','http://www.w3.org/2000/svg');
  outSvg.setAttribute('width', svg.clientWidth);
  outSvg.setAttribute('height', svg.clientHeight);
  outSvg.appendChild(view);
  const s = new XMLSerializer().serializeToString(outSvg);
  const blob = new Blob([s], {type:'image/svg+xml;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'board.svg'; a.click();
  URL.revokeObjectURL(url);
}

function exportPNG(){
  // Render exported SVG to canvas to get PNG
  const serializer = new XMLSerializer();
  // produce svg string of world content with a white background
  const w = svg.clientWidth, h = svg.clientHeight;
  const clone = svg.cloneNode(true);
  clone.setAttribute('width', w);
  clone.setAttribute('height', h);
  const s = serializer.serializeToString(clone);
  const img = new Image();
  const svgBlob = new Blob([s], {type:'image/svg+xml;charset=utf-8'});
  const url = URL.createObjectURL(svgBlob);
  img.onload = function(){
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const ctx = c.getContext('2d');
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,w,h);
    ctx.drawImage(img,0,0);
    URL.revokeObjectURL(url);
    c.toBlob(function(blob){
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'board.png'; a.click();
    });
  };
  img.src = url;
}

/* ========= Persistence ========= */
function save(){
  try{
    const data = world.innerHTML;
    localStorage.setItem('mini_miro_board_v2', JSON.stringify({
      inner: data,
      view: { scale: state.scale, translate: state.translate }
    }));
  }catch(e){}
}
function load(){
  try{
    const raw = localStorage.getItem('mini_miro_board_v2');
    if(!raw) return;
    const obj = JSON.parse(raw);
    world.innerHTML = obj.inner;
    state.scale = obj.view.scale || 1;
    state.translate = obj.view.translate || {x:0,y:0};
    // reattach events on nodes and styles
    Array.from(world.children).forEach(n=>attachElementEvents(n));
    applyTransform();
  }catch(e){}
}
load();

/* ========= initial sample shapes ========= */
(function seed(){
  const a = createElement('rect', 40, 40, 160, 100);
  const b = createElement('ellipse', 260, 80, 140, 90);
  const s = createElement('sticky', 160, 220, 140, 100);
  const t = createElement('text', 60, 160, 160, 30, {text:'Hello'});
  // add arrow marker def
  const defs = svg.querySelector('defs');
  const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
  marker.setAttribute('id','arrow'); marker.setAttribute('markerWidth','10'); marker.setAttribute('markerHeight','10');
  marker.setAttribute('refX','8'); marker.setAttribute('refY','3'); marker.setAttribute('orient','auto');
  const path = document.createElementNS('http://www.w3.org/2000/svg','path'); path.setAttribute('d','M0,0 L0,6 L9,3 z'); path.setAttribute('fill','#333');
  marker.appendChild(path); defs.appendChild(marker);
  applyTransform();
  save();
})();

/* ========= Keyboard shortcuts (desktop) ========= */
window.addEventListener('keydown', (e)=>{
  if(e.key === 'Delete' || e.key === 'Backspace'){ if(state.selected){ state.selected.remove(); const prev = world.querySelector('#__sel'); if(prev) prev.remove(); state.selected=null; save(); } }
  if(e.ctrlKey && e.key==='d'){ // duplicate
    if(state.selected){
      const clone = state.selected.cloneNode(true);
      world.appendChild(clone);
      attachElementEvents(clone);
      clone.setAttribute('transform','translate(20,20)');
      save();
    }
  }
});

/* ========= save on changes ========= */
const obs = new MutationObserver(()=>{ save(); });
obs.observe(world, { childList:true, subtree:true, attributes:true, characterData:true });

/* ========= helper save on window blur ========= */
window.addEventListener('blur', save);
window.addEventListener('beforeunload', save);

/* ========= simple helpers to group/ungroup (placeholders) ========= */
function groupSelected(){ alert('Multi-select + group requires UI for selecting multiple items. This demo is focused on features: pan/zoom, shapes, pen, connectors, snap, export. Full multi-select grouping can be added next.'); }
function ungroupSelected(){ alert('Ungroup placeholder.'); }

/* ========= small feature notes ========= */
// This single-file demo provides the core: infinite-ish canvas (pan + zoom), many shapes, freehand pen, connectors, resize handles, snap-to-grid, frames, mobile pinch-zoom, export, and persistence.
// Advanced features missing or simplified: real-time collaboration, multi-select marquee, complex grouping transforms, PDF export, advanced text formatting. Those can be added iteratively.

</script>
</body>
</html>
