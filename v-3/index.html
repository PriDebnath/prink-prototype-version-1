<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Miro ‚Äî Canvas (sticky, multi-select, resize, pan/zoom, grid, connectors, undo/redo)</title>
<style>
  :root{
    --sidebar-w:72px;
    --bgstart:#f3f6fb;
    --bgend:#fff;
    --accent:#2563eb;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial,sans-serif;-webkit-font-smoothing:antialiased;}
  .app{display:flex;height:100vh;overflow:hidden;touch-action:none}
  .sidebar{
    width:var(--sidebar-w);background:#fff;border-right:1px solid #e6e9ef;
    display:flex;flex-direction:column;align-items:center;padding:12px 8px;gap:12px;box-sizing:border-box;
  }
  .tool-btn{
    width:56px;height:56px;border-radius:12px;display:flex;align-items:center;justify-content:center;
    border:1px solid #ddd;background:#fafafa;cursor:pointer;user-select:none;font-size:22px;
    box-shadow:0 1px 0 rgba(0,0,0,0.03);transition:all .12s;
  }
  .tool-btn.active{border-color:var(--accent);box-shadow:0 6px 18px rgba(37,99,235,0.12);background:#e8f0fe;color:var(--accent)}
  .tool-label{font-size:11px;margin-top:4px;color:#666;text-align:center}
  canvas{flex:1;display:block;background:linear-gradient(180deg,var(--bgstart),var(--bgend));touch-action:none}
  #editor{position:absolute;display:none;box-sizing:border-box;min-width:120px;min-height:60px;padding:8px;border-radius:8px;
    font:14px/1.2 Inter, system-ui, Arial;box-shadow:0 6px 20px rgba(0,0,0,0.14);background:#fff9c4;border:1px solid rgba(0,0,0,0.04);
    outline:none;resize:none;overflow:auto;z-index:1000;-webkit-user-modify: read-write-plaintext-only;}
  .toolbar-bottom{
    position:absolute;left:calc(var(--sidebar-w) + 14px);bottom:14px;background:rgba(255,255,255,0.9);padding:8px;border-radius:8px;
    box-shadow:0 6px 20px rgba(0,0,0,0.08);display:flex;gap:8px;align-items:center;font-size:13px;
  }
  .chip{padding:6px 8px;border-radius:8px;background:#fff;border:1px solid #e6e9ef;cursor:pointer}
  .chip.toggle-on{background:#e8f0fe;border-color:var(--accent);color:var(--accent)}
  @media (max-width:520px){.tool-btn{width:52px;height:52px;font-size:20px}}
</style>
</head>
<body>
  <div class="app">
    <div class="sidebar" role="toolbar" aria-label="Tools">
      <div>
        <button id="tool-sticky" class="tool-btn active" title="Sticky Note">üìù</button>
        <div class="tool-label">Sticky</div>
      </div>
      <div>
        <button id="tool-select" class="tool-btn" title="Select">üî≤</button>
        <div class="tool-label">Select</div>
      </div>
      <div>
        <button id="tool-connect" class="tool-btn" title="Connect">üîó</button>
        <div class="tool-label">Connect</div>
      </div>
    </div>

    <canvas id="board" aria-label="Canvas board"></canvas>
    <div id="editor" contenteditable="true" spellcheck="false" role="textbox" aria-multiline="true"></div>

    <div class="toolbar-bottom" id="bottomBar">
      <div class="chip" id="undoBtn">Undo (Ctrl+Z)</div>
      <div class="chip" id="redoBtn">Redo (Ctrl+Y)</div>
      <div class="chip" id="snapToggle">Snap: ON</div>
      <div class="chip" id="gridToggle">Grid: ON</div>
      <div style="margin-left:8px;color:#666;font-size:12px">Pan: Space+Drag / Middle mouse or two-finger</div>
    </div>
  </div>

<script>
(() => {
  // --- DOM ---
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d', { alpha: false });
  const editor = document.getElementById('editor');
  const stickyBtn = document.getElementById('tool-sticky');
  const selectBtn = document.getElementById('tool-select');
  const connectBtn = document.getElementById('tool-connect');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const snapToggle = document.getElementById('snapToggle');
  const gridToggle = document.getElementById('gridToggle');

  // --- State / Data Model ---
  let notes = []; // {id,x,y,w,h,text,color}
  let connectors = []; // {id,aId,bId}
  let idCounter = 1;
  let connectorIdCounter = 1;

  // Viewport transform
  let panX = 0, panY = 0, scale = 1;

  // interaction state
  let currentTool = 'sticky'; // 'sticky'|'select'|'connect'
  let selectedIds = new Set(); // support multi-select
  let primarySelectedId = null; // for resize/handles (single)
  let dragging = null; // {type:'move'|'pan'|'resize', info...}
  let marquee = null; // {x1,y1,x2,y2} in world coords
  let connectFirst = null; // for connect tool: first note selected
  let pointerMap = new Map(); // pointerId -> {x,y} for gestures

  // undo/redo
  let history = [], historyIndex = -1, historyLimit = 80;

  // options
  let snapToGrid = true;
  const gridSize = 16;
  let showGrid = true;

  // helpers: canvas resize
  function resizeCanvas(){
    const sidebarW = document.querySelector('.sidebar').offsetWidth;
    canvas.width = Math.max(600, window.innerWidth - sidebarW);
    canvas.height = Math.max(300, window.innerHeight);
    draw();
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Helper: world <-> screen coordinates
  function worldToScreen(wx, wy){
    return { x: (wx * scale) + panX, y: (wy * scale) + panY };
  }
  function screenToWorld(sx, sy){
    return { x: (sx - panX) / scale, y: (sy - panY) / scale };
  }

  // Utility: deep copy of state for history
  function snapshot(){
    return {
      notes: notes.map(n => ({...n})),
      connectors: connectors.map(c => ({...c})),
      selectedIds: Array.from(selectedIds)
    };
  }
  function restoreSnapshot(snap){
    notes = snap.notes.map(n => ({...n}));
    connectors = snap.connectors.map(c => ({...c}));
    selectedIds = new Set(snap.selectedIds);
    primarySelectedId = (selectedIds.size === 1) ? Array.from(selectedIds)[0] : null;
    draw();
  }
  function pushHistory(label){
    // prune forward history if any
    if(historyIndex < history.length - 1) history = history.slice(0, historyIndex + 1);
    history.push(snapshot());
    if(history.length > historyLimit) history.shift();
    historyIndex = history.length - 1;
  }
  function undo(){
    if(historyIndex <= 0) return;
    historyIndex--;
    const snap = history[historyIndex];
    restoreSnapshot(snap);
  }
  function redo(){
    if(historyIndex >= history.length - 1) return;
    historyIndex++;
    const snap = history[historyIndex];
    restoreSnapshot(snap);
  }

  // Rounded rect polyfill
  if(!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r=8){
      this.beginPath();
      this.moveTo(x + r, y);
      this.arcTo(x + w, y, x + w, y + h, r);
      this.arcTo(x + w, y + h, x, y + h, r);
      this.arcTo(x, y + h, x, y, r);
      this.arcTo(x, y, x + w, y, r);
      this.closePath();
    };
  }

  // Create note
  function createNote(wx, wy, text='New note'){
    const w = 180, h = 120;
    const note = { id: idCounter++, x: wx - w/2, y: wy - h/2, w, h, text, color: '#fff9c4' };
    notes.push(note);
    pushHistory();
    draw();
    return note;
  }

  // Create connector
  function createConnector(aId, bId){
    if(!aId || !bId || aId === bId) return null;
    // prevent duplicates
    const exists = connectors.some(c => (c.aId===aId && c.bId===bId) || (c.aId===bId && c.bId===aId));
    if(exists) return null;
    const conn = { id: connectorIdCounter++, aId, bId };
    connectors.push(conn);
    pushHistory();
    draw();
    return conn;
  }

  // Hit testing (top-down)
  function hitTestNotes(wx, wy){
    for(let i = notes.length - 1; i >= 0; i--){
      const n = notes[i];
      if(wx >= n.x && wx <= n.x + n.w && wy >= n.y && wy <= n.y + n.h) return n;
    }
    return null;
  }

  // Drawing functions
  function drawGrid(){
    if(!showGrid) return;
    const step = gridSize * scale;
    if(step < 6) return; // avoid drawing too dense
    ctx.save();
    ctx.strokeStyle = 'rgba(0,0,0,0.04)';
    ctx.lineWidth = 1;
    // vertical lines
    const startX = panX % step;
    for(let x = startX; x < canvas.width; x += step){
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
    // horizontal lines
    const startY = panY % step;
    for(let y = startY; y < canvas.height; y += step){
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }
    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // background
    ctx.fillStyle = '#f7f9fc';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    // grid
    drawGrid();

    // connectors first (so notes draw on top)
    connectors.forEach(conn => {
      const a = notes.find(n => n.id === conn.aId);
      const b = notes.find(n => n.id === conn.bId);
      if(!a || !b) return;
      const aC = worldToScreen(a.x + a.w/2, a.y + a.h/2);
      const bC = worldToScreen(b.x + b.w/2, b.y + b.h/2);
      // simple bezier
      ctx.save();
      ctx.strokeStyle = 'rgba(30,30,30,0.45)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(aC.x, aC.y);
      const dx = (bC.x - aC.x) * 0.4;
      ctx.bezierCurveTo(aC.x + dx, aC.y, bC.x - dx, bC.y, bC.x, bC.y);
      ctx.stroke();
      // arrow head
      const angle = Math.atan2(bC.y - aC.y, bC.x - aC.x);
      const arrowSize = 8;
      ctx.beginPath();
      ctx.moveTo(bC.x, bC.y);
      ctx.lineTo(bC.x - arrowSize * Math.cos(angle - Math.PI/6), bC.y - arrowSize * Math.sin(angle - Math.PI/6));
      ctx.lineTo(bC.x - arrowSize * Math.cos(angle + Math.PI/6), bC.y - arrowSize * Math.sin(angle + Math.PI/6));
      ctx.closePath();
      ctx.fillStyle = 'rgba(30,30,30,0.6)';
      ctx.fill();
      ctx.restore();
    });

    // notes
    notes.forEach(note => {
      const s = worldToScreen(note.x, note.y);
      const sw = note.w * scale;
      const sh = note.h * scale;

      // shadow
      ctx.save();
      ctx.shadowColor = 'rgba(16,24,40,0.08)';
      ctx.shadowBlur = 10;
      // shape
      ctx.fillStyle = note.color;
      ctx.strokeStyle = selectedIds.has(note.id) ? 'rgba(37,99,235,0.95)' : 'rgba(0,0,0,0.08)';
      ctx.lineWidth = selectedIds.has(note.id) ? 3 : 1.5;
      ctx.roundRect(s.x, s.y, sw, sh, 8 * scale);
      ctx.fill();
      ctx.stroke();

      // text (scale friendly)
      ctx.fillStyle = '#111827';
      ctx.font = `${Math.max(12, 14 * scale)}px Inter, system-ui, Arial`;
      // draw wrapped text manually: convert max width in world units and scale text position
      const padding = 10 * scale;
      const textMaxWidth = sw - padding * 2;
      const lines = wrapTextLines(ctx, note.text, textMaxWidth);
      let ty = s.y + padding + (12 * scale);
      for(const line of lines){
        ctx.fillText(line, s.x + padding, ty);
        ty += (18 * scale);
      }
      ctx.restore();

      // draw handles if single selected
      if(primarySelectedId === note.id){
        drawHandlesForNote(note);
      }
    });

    // marquee selection (screen coords)
    if(marquee){
      ctx.save();
      const a = worldToScreen(marquee.x1, marquee.y1);
      const b = worldToScreen(marquee.x2, marquee.y2);
      const mx = Math.min(a.x, b.x), my = Math.min(a.y, b.y);
      const mw = Math.abs(a.x - b.x), mh = Math.abs(a.y - b.y);
      ctx.strokeStyle = 'rgba(37,99,235,0.6)'; ctx.lineWidth = 1.5;
      ctx.setLineDash([6,6]);
      ctx.strokeRect(mx, my, mw, mh);
      ctx.fillStyle = 'rgba(37,99,235,0.06)';
      ctx.fillRect(mx, my, mw, mh);
      ctx.restore();
    }
  }

  function drawHandlesForNote(note){
    const s = worldToScreen(note.x, note.y);
    const sw = note.w * scale, sh = note.h * scale;
    const size = Math.max(8, 8 * scale);
    const half = size / 2;
    const handles = [
      {x: s.x - half, y: s.y - half, cursor: 'nwse-resize', name: 'nw'},
      {x: s.x + sw - half, y: s.y - half, cursor: 'nesw-resize', name: 'ne'},
      {x: s.x - half, y: s.y + sh - half, cursor: 'nesw-resize', name: 'sw'},
      {x: s.x + sw - half, y: s.y + sh - half, cursor: 'nwse-resize', name: 'se'}
    ];
    ctx.save();
    ctx.fillStyle = '#fff'; ctx.strokeStyle = '#666'; ctx.lineWidth = 1;
    for(const h of handles){
      ctx.beginPath(); ctx.rect(h.x, h.y, size, size); ctx.fill(); ctx.stroke();
    }
    ctx.restore();
  }

  function wrapTextLines(ctx, text, maxWidth){
    if(!text) return [''];
    const words = String(text).split(/\s+/);
    const lines = []; let line = '';
    for(let i=0;i<words.length;i++){
      const test = line ? (line + ' ' + words[i]) : words[i];
      if(ctx.measureText(test).width > maxWidth && line){
        lines.push(line); line = words[i];
      } else { line = test; }
    }
    lines.push(line);
    return lines;
  }

  // Selection helpers
  function selectNoteId(id, add=false){
    if(!add) selectedIds.clear();
    if(id !== null) selectedIds.add(id);
    primarySelectedId = (selectedIds.size === 1) ? Array.from(selectedIds)[0] : null;
    draw();
  }

  function selectNoteIdToggle(id){
    if(selectedIds.has(id)) selectedIds.delete(id);
    else selectedIds.add(id);
    primarySelectedId = (selectedIds.size === 1) ? Array.from(selectedIds)[0] : null;
    draw();
  }

  // Snap helper
  function snap(value){
    if(!snapToGrid) return value;
    return Math.round(value / gridSize) * gridSize;
  }

  // --- Input & Interaction ---

  // track pointer positions for gestures
  canvas.addEventListener('pointerdown', (ev) => {
    canvas.setPointerCapture(ev.pointerId);
    pointerMap.set(ev.pointerId, {x: ev.clientX, y: ev.clientY});

    const screen = { x: ev.clientX - canvas.getBoundingClientRect().left, y: ev.clientY - canvas.getBoundingClientRect().top };
    const world = screenToWorld(screen.x, screen.y);

    // tool behaviors
    if(currentTool === 'sticky'){
      const newNote = createNote(world.x, world.y, 'New note');
      // select it
      selectNoteId(newNote.id, false);
      pushHistory();
      return;
    }

    if(currentTool === 'connect'){
      const hit = hitTestNotes(world.x, world.y);
      if(hit){
        if(!connectFirst){
          connectFirst = hit.id;
          // visually mark by selecting single
          selectedIds.clear(); selectedIds.add(hit.id);
          primarySelectedId = hit.id;
          draw();
        } else {
          // create connector between connectFirst and hit.id
          createConnector(connectFirst, hit.id);
          connectFirst = null;
          selectedIds.clear();
          primarySelectedId = null;
          draw();
        }
      }
      return;
    }

    // select tool
    const hit = hitTestNotes(world.x, world.y);
    const isSpace = ev.getModifierState && ev.getModifierState('Space');
    const isShift = ev.shiftKey;

    // pan with middle or spacebar or two-finger (we'll detect two pointers outside here)
    const isMiddle = (ev.button === 1);
    if(isMiddle || isSpace || pointerMap.size >= 2){
      // start panning
      dragging = { type: 'pan', startClient: {x: ev.clientX, y: ev.clientY}, startPan: {x: panX, y: panY} };
      return;
    }

    if(hit){
      // bring to front
      bringToFront(hit.id);
      if(isShift){
        // toggle selection
        selectNoteIdToggle(hit.id);
      } else {
        if(!selectedIds.has(hit.id)){
          selectNoteId(hit.id, false);
        }
      }
      // start move of selected set
      const offsets = {};
      selectedIds.forEach(sid => {
        const n = notes.find(z => z.id === sid);
        offsets[sid] = { x: world.x - n.x, y: world.y - n.y };
      });
      dragging = { type: 'move', offsets };
      pushHistory(); // start move: push state so undo will revert move start
    } else {
      // clicked empty -> start marquee selection
      selectedIds.clear(); primarySelectedId = null;
      marquee = { x1: world.x, y1: world.y, x2: world.x, y2: world.y };
      dragging = { type: 'marquee' };
      draw();
    }
  });

  canvas.addEventListener('pointermove', (ev) => {
    const prev = pointerMap.get(ev.pointerId);
    pointerMap.set(ev.pointerId, {x: ev.clientX, y: ev.clientY});

    if(dragging && dragging.type === 'pan'){
      // pan logic
      const dx = ev.clientX - dragging.startClient.x;
      const dy = ev.clientY - dragging.startClient.y;
      panX = dragging.startPan.x + dx;
      panY = dragging.startPan.y + dy;
      draw();
      return;
    }

    if(!dragging) return;

    const screen = { x: ev.clientX - canvas.getBoundingClientRect().left, y: ev.clientY - canvas.getBoundingClientRect().top };
    const world = screenToWorld(screen.x, screen.y);

    if(dragging.type === 'move'){
      // move all selected according to pointer world position & stored offsets
      selectedIds.forEach(sid => {
        const n = notes.find(z => z.id === sid);
        const off = dragging.offsets[sid];
        if(n && off){
          n.x = snap(world.x - off.x);
          n.y = snap(world.y - off.y);
        }
      });
      draw();
    } else if(dragging.type === 'marquee'){
      marquee.x2 = world.x; marquee.y2 = world.y;
      // update selection based on marquee bounds
      const left = Math.min(marquee.x1, marquee.x2), right = Math.max(marquee.x1, marquee.x2);
      const top = Math.min(marquee.y1, marquee.y2), bottom = Math.max(marquee.y1, marquee.y2);
      selectedIds.clear();
      notes.forEach(n => {
        if(!(n.x > right || n.x + n.w < left || n.y > bottom || n.y + n.h < top)){
          selectedIds.add(n.id);
        }
      });
      primarySelectedId = (selectedIds.size === 1) ? Array.from(selectedIds)[0] : null;
      draw();
    } else if(dragging.type === 'resize'){
      // resizing primarySelectedId with handle info
      const note = notes.find(n => n.id === dragging.noteId);
      if(!note) return;
      // compute anchor depending on handle
      const start = dragging.start; // contains original values
      if(dragging.handle === 'se'){
        // new width = (world.x - start.x) ; height = ...
        let newW = world.x - start.x;
        let newH = world.y - start.y;
        if(newW < 30) newW = 30; if(newH < 30) newH = 30;
        if(snapToGrid){ newW = Math.round(newW / gridSize) * gridSize; newH = Math.round(newH / gridSize) * gridSize; }
        note.w = newW; note.h = newH;
      } else if(dragging.handle === 'nw'){
        let dx = world.x - start.x;
        let dy = world.y - start.y;
        let newX = start.origX + dx;
        let newY = start.origY + dy;
        let newW = start.origW - dx;
        let newH = start.origH - dy;
        if(newW < 30){ newW = 30; newX = start.origX + (start.origW - 30); }
        if(newH < 30){ newH = 30; newY = start.origY + (start.origH - 30); }
        if(snapToGrid){ newX = snap(newX); newY = snap(newY); newW = Math.round(newW / gridSize) * gridSize; newH = Math.round(newH / gridSize) * gridSize; }
        note.x = newX; note.y = newY; note.w = newW; note.h = newH;
      } else if(dragging.handle === 'ne'){
        let dy = world.y - start.y;
        let newY = start.origY + dy;
        let newW = world.x - start.origX;
        let newH = start.origH - dy;
        if(newW < 30) newW = 30;
        if(newH < 30){ newH = 30; newY = start.origY + (start.origY + start.origH - (start.origY + 30)); }
        if(snapToGrid){ newW = Math.round(newW / gridSize) * gridSize; newY = snap(newY); newH = Math.round(newH / gridSize) * gridSize; }
        note.y = newY; note.w = newW; note.h = newH;
      } else if(dragging.handle === 'sw'){
        let dx = world.x - start.x;
        let newX = start.origX + dx;
        let newW = start.origW - dx;
        let newH = world.y - start.origY;
        if(newW < 30){ newW = 30; newX = start.origX + (start.origW - 30); }
        if(newH < 30) newH = 30;
        if(snapToGrid){ newX = snap(newX); newW = Math.round(newW / gridSize) * gridSize; newH = Math.round(newH / gridSize) * gridSize; }
        note.x = newX; note.w = newW; note.h = newH;
      }
      draw();
    }
  });

  canvas.addEventListener('pointerup', (ev) => {
    canvas.releasePointerCapture(ev.pointerId);
    pointerMap.delete(ev.pointerId);

    if(dragging && (dragging.type === 'move' || dragging.type === 'resize')){
      // finalize action -> push history
      pushHistory();
    }
    if(dragging && dragging.type === 'marquee'){
      marquee = null;
    }
    dragging = null;
    draw();
  });

  // Helper to bring note to front
  function bringToFront(noteId){
    const idx = notes.findIndex(n => n.id === noteId);
    if(idx >= 0){
      const [n] = notes.splice(idx,1);
      notes.push(n);
    }
  }

  // Pointer double-tap/dblclick to edit: we'll detect quick successive pointerup
  let lastUpTime = 0;
  canvas.addEventListener('pointerup', (ev) => {
    const now = Date.now();
    const dt = now - lastUpTime;
    lastUpTime = now;
    if(dt < 300){
      // double-tap/dblclick
      const screen = { x: ev.clientX - canvas.getBoundingClientRect().left, y: ev.clientY - canvas.getBoundingClientRect().top };
      const world = screenToWorld(screen.x, screen.y);
      const hit = hitTestNotes(world.x, world.y);
      if(hit){
        openEditor(hit);
      }
    }
  });

  // Resize handles detection on pointerdown (when a single note selected & pointer on handle)
  canvas.addEventListener('pointerdown', (ev) => {
    // we run this additional handler to detect handles; ensure it doesn't conflict
    const screen = { x: ev.clientX - canvas.getBoundingClientRect().left, y: ev.clientY - canvas.getBoundingClientRect().top };
    const world = screenToWorld(screen.x, screen.y);
    if(primarySelectedId !== null){
      const note = notes.find(n => n.id === primarySelectedId);
      if(note){
        // compute handle rectangles in screen space
        const s = worldToScreen(note.x, note.y);
        const sw = note.w * scale, sh = note.h * scale;
        const size = Math.max(8, 8 * scale);
        const half = size / 2;
        const handleRects = {
          nw: {x: s.x - half, y: s.y - half, w: size, h: size},
          ne: {x: s.x + sw - half, y: s.y - half, w: size, h: size},
          sw: {x: s.x - half, y: s.y + sh - half, w: size, h: size},
          se: {x: s.x + sw - half, y: s.y + sh - half, w: size, h: size},
        };
        for(const [name, r] of Object.entries(handleRects)){
          if(screen.x >= r.x && screen.x <= r.x + r.w && screen.y >= r.y && screen.y <= r.y + r.h){
            // start resize operation
            const noteCopy = {...note};
            dragging = {
              type: 'resize', noteId: note.id, handle: name,
              start: { x: world.x, y: world.y, origX: noteCopy.x, origY: noteCopy.y, origW: noteCopy.w, origH: noteCopy.h }
            };
            // capture pointer done in earlier pointerdown handler
            pushHistory();
            ev.preventDefault();
            return;
          }
        }
      }
    }
  });

  // Keyboard events
  window.addEventListener('keydown', (e) => {
    const isCmd = e.ctrlKey || e.metaKey;
    if(isCmd && (e.key === 'z' || e.key === 'Z')){ e.preventDefault(); undo(); return; }
    if(isCmd && (e.key === 'y' || e.key === 'Y')){ e.preventDefault(); redo(); return; }
    if(e.key === 'Delete' || e.key === 'Backspace'){
      if(selectedIds.size > 0){
        notes = notes.filter(n => !selectedIds.has(n.id));
        connectors = connectors.filter(c => !selectedIds.has(c.aId) && !selectedIds.has(c.bId));
        selectedIds.clear(); primarySelectedId = null;
        pushHistory();
        draw();
      }
    }
    if(e.key === 'Escape'){
      selectedIds.clear(); primarySelectedId = null; marquee = null; connectFirst = null; hideEditor(); draw();
    }
    // hold Space for pan (space handling done in pointerdown via ev.getModifierState)
  });

  // Mouse wheel for zoom (centered at cursor)
  canvas.addEventListener('wheel', (ev) => {
    ev.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const screenX = ev.clientX - rect.left;
    const screenY = ev.clientY - rect.top;
    const worldBefore = screenToWorld(screenX, screenY);
    const delta = -ev.deltaY;
    const zoomFactor = Math.exp(delta * 0.0015);
    const newScale = Math.max(0.2, Math.min(3, scale * zoomFactor));
    scale = newScale;
    // adjust pan so that worldBefore stays at same screen position
    const worldAfterScreen = worldToScreen(worldBefore.x, worldBefore.y);
    panX += screenX - worldAfterScreen.x;
    panY += screenY - worldAfterScreen.y;
    draw();
  }, {passive:false});

  // Pinch-to-zoom & two-finger pan (basic)
  // we use pointer events: when 2 pointers present calculate distance
  function handleGesture(){
    if(pointerMap.size < 2) return;
    const pts = Array.from(pointerMap.values());
    const p0 = pts[0], p1 = pts[1];
    const midX = (p0.x + p1.x) / 2;
    const midY = (p0.y + p1.y) / 2;
    const dist = Math.hypot(p0.x - p1.x, p0.y - p1.y);
    if(!handleGesture.last) handleGesture.last = {dist, midX, midY, scale, panX, panY};
    else {
      const ls = handleGesture.last;
      const factor = dist / ls.dist;
      const newScale = Math.max(0.2, Math.min(3, ls.scale * factor));
      // center at mid
      const rect = canvas.getBoundingClientRect();
      const screenMidX = midX - rect.left;
      const screenMidY = midY - rect.top;
      const worldAtMid = screenToWorld(screenMidX, screenMidY);
      scale = newScale;
      const after = worldToScreen(worldAtMid.x, worldAtMid.y);
      panX += screenMidX - after.x;
      panY += screenMidY - after.y;
      draw();
    }
  }
  canvas.addEventListener('pointermove', (ev) => {
    // call gesture recalculation on pointermove globally (we already set pointerMap earlier)
    if(pointerMap.size >= 2) handleGesture();
  });

  canvas.addEventListener('pointerup', () => { handleGesture.last = null; });

  // Editor overlay
  function openEditor(note){
    const screenPos = worldToScreen(note.x, note.y);
    const canvasRect = canvas.getBoundingClientRect();
    editor.style.display = 'block';
    editor.style.left = (canvasRect.left + screenPos.x + 8) + 'px';
    editor.style.top = (canvasRect.top + screenPos.y + 8) + 'px';
    editor.style.width = Math.max(120, note.w - 12) + 'px';
    editor.style.height = Math.max(60, note.h - 12) + 'px';
    editor.innerText = note.text;
    editor.focus();
    // save on blur
    editor.onblur = () => {
      note.text = editor.innerText || '';
      editor.style.display = 'none';
      pushHistory();
      draw();
    };
    editor.onkeydown = (ev) => {
      if((ev.ctrlKey || ev.metaKey) && ev.key === 'Enter'){ editor.blur(); }
    };
  }
  function hideEditor(){ editor.style.display = 'none'; }

  // toolbar interactions
  stickyBtn.addEventListener('click', () => { setTool('sticky'); });
  selectBtn.addEventListener('click', () => { setTool('select'); });
  connectBtn.addEventListener('click', () => { setTool('connect'); });

  function setTool(t){
    currentTool = t;
    stickyBtn.classList.toggle('active', t === 'sticky');
    selectBtn.classList.toggle('active', t === 'select');
    connectBtn.classList.toggle('active', t === 'connect');
    // reset connect state
    connectFirst = null;
    selectedIds.clear(); primarySelectedId = null;
    hideEditor();
    draw();
  }

  // bottom toolbar toggles
  undoBtn.addEventListener('click', undo);
  redoBtn.addEventListener('click', redo);

  gridToggle.addEventListener('click', () => { showGrid = !showGrid; gridToggle.classList.toggle('toggle-on', showGrid); gridToggle.innerText = 'Grid: ' + (showGrid ? 'ON' : 'OFF'); draw(); });
  snapToggle.addEventListener('click', () => { snapToGrid = !snapToGrid; snapToggle.classList.toggle('toggle-on', snapToGrid); snapToggle.innerText = 'Snap: ' + (snapToGrid ? 'ON' : 'OFF'); });

  // Helper: find handle name under screen point -> used for cursor feedback
  function handleAtScreenPoint(sx, sy){
    if(primarySelectedId === null) return null;
    const note = notes.find(n => n.id === primarySelectedId);
    if(!note) return null;
    const s = worldToScreen(note.x, note.y); const sw = note.w * scale; const sh = note.h * scale;
    const size = Math.max(8, 8 * scale); const half = size/2;
    const handles = {
      nw: {x: s.x - half, y: s.y - half, w: size, h: size},
      ne: {x: s.x + sw - half, y: s.y - half, w: size, h: size},
      sw: {x: s.x - half, y: s.y + sh - half, w: size, h: size},
      se: {x: s.x + sw - half, y: s.y + sh - half, w: size, h: size}
    };
    for(const [name,r] of Object.entries(handles)){
      if(sx >= r.x && sx <= r.x + r.w && sy >= r.y && sy <= r.y + r.h) return name;
    }
    return null;
  }

  // Pointer move to set cursor style when on handle
  canvas.addEventListener('pointermove', (ev) => {
    const rect = canvas.getBoundingClientRect();
    const sx = ev.clientX - rect.left, sy = ev.clientY - rect.top;
    const h = handleAtScreenPoint(sx, sy);
    canvas.style.cursor = h ? (h === 'nw' || h === 'se' ? 'nwse-resize' : 'nesw-resize') : 'default';
  });

  // initial sample notes
  createNote(240, 200, 'Double-tap to edit');
  createNote(520, 220, 'Sticky #2');

  // helpers exposed for debugging
  window._mini = { notes, connectors, createNote, createConnector, undo, redo, setTool };

  // initialize history with initial state
  pushHistory();
  draw();

})();
</script>
</body>
</html>
